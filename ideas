Path selection patterns ( /root/*/access) which can be sources for "virtual trees"

What we shold handle?
-virtual or surrogate trees (trees or value, calculated on-the-fly without any storage)
-caching and memoization of virtual trees
-linking values to each other and linking fragments of trees which mimics concept of mounts in filesystem
-transactional changes with comments (mimics special tables in SQL DBs we can store transactions in the same configuration tree)
-handle comments as a part of configuration
-scripting of handlers for virtual trees or variables
-access control (possibly would be useful to store attributes with the same interface of configuration as MySQL does)

Look at XPath and XQuery!

Library datamodel regarding basic types follows strictly typed languages:
there is following decimal types scheme:
{ signed | unsigned } int[ 8 | 16 | 32 | 64 ]
there are floating point type:
float | double
there are bitfield type:
bits[ num ] // num == 1 - boolean value

complex types simulated via special things:
node dictionary adapters:
hash, -  any regular datatype
patricia, - strings (default)
array, - child node names in such node is numbers only
{ sorted | unsorted } list -

pluggable datatype system

config schemas with comments and type definition. variables are allowed. for example:

plugin {
	name = string;
	config = subtree( ../plugins/$${./name} )
}

here is ./name should be string or convertable to string parameter
$$ means that expansion will be performed during config tree building
instead of schema itself tree building stage

${./name} - insert mentioned node value into position at first stage
$${./name} - the same but at the sacond stage.
$[n]{./name} - at the n-th stage

Plugin for variable expansion.

data scheme is config itself
What does scheme allow to do? Automatic type conversion from original or
genuine tree. For example, string "white" for color will be converted into
1-element blob with element length == 4(bytes)

What blob is:

typedef struct {
  unsigned int bendian : 1; //  == 1 if saved on big-endian host
  unsigned int float : 1; // == 1 if is floating point number
  unsigned int array : 1; // == 1 if blob is array of elements
  unsigned int bsize : 5; // block size (or size of element in the case of array)
} header;

typedef struct {
  header;
  char data[];
} scalar;

typedef struct {
  header;
  uint32_t length;
  char data[];
} vector;

Tool for test configuration. Again, we need the module for configuration versioning!

Probably, we should have ability to backup and store succesful configurations of system
in our advanced versioning plugin. Yep, something similar to restore points in
EvilXP/NT/2000/3000/10000

Run-time configuration editing with mentioned toolbox. Adding/deleting in runtime. Not
sure about how exactly application should be notified about config change.

Module mounter - mount different part of tree to new position.
Module lazy builder - ping underlaid sub-tree module only when accessed
Module cacher - cache config into provided sub-tree of global namespace
Module engine::shm - stores result into shared memory segments; may be useful with cacher

Don't forget about config-selection globbing with XPath like expressions. We should have
an ability to build virtual subtree from real one with help of XPath-like expression.

Idea of "layers" of configuration. Actually, tree might be represented as 3d construction
where Z-coordinate is responsible for concrete layer of configuration. Layers are combined
according to their priority to d[it out resulting configuration tree.
Example of layers:
-hardware - configuration tree for particular hardware platform
-system - conf tree for particular OS installation
-user - conf tree related to loggged-in user.
...
Application can have self-defined configuration layers.
Layers are being applied as series of pathes. Resulting tree might obtain
on of its values from one level and another value from another. Values can
interfere with each other. I think word priority in this area would be
sufficient but I'm not sure. Separate plugin should be provided for such
kind of feature.

Allow in scheme plugin units of measurement.

Plugin-calculator which allows to perform calculations during config read. Kind
of setter-getter virtual variable.

We should discuss cyclic graph problem in the case of dependency in tree's
members computation.
