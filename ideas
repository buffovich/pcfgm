Path selection patterns ( /root/*/access) which can be sources for "virtual trees"

What we shold handle?
-virtual or surrogate trees (trees or value, calculated on-the-fly without any storage)
-caching and memoization of virtual trees
-linking values to each other and linking fragments of trees which mimics concept of mounts in filesystem
-transactional changes with comments (mimics special tables in SQL DBs we can store transactions in the same configuration tree)
-handle comments as a part of configuration
-scripting of handlers for virtual trees or variables
-access control (possibly would be useful to store attributes with the same interface of configuration as MySQL does)

Look at XPath and XQuery!

Library datamodel regarding basic types follows strictly typed languages:
there is following decimal types scheme:
{ signed | unsigned } int[ 8 | 16 | 32 | 64 ]
there are floating point type:
float | double
there are bitfield type:
bits[ num ] // num == 1 - boolean value

complex types simulated via special things:
node dictionary adapters:
hash, -  any regular datatype
patricia, - strings (default)
array, - child node names in such node is numbers only
{ sorted | unsorted } list -

pluggable datatype system

config schemas with comments and type definition. variables are allowed. for example:

plugin {
	name = string;
	config = subtree( ../plugins/$${./name} )
}

here is ./name should be string or convertable to string parameter
$$ means that expansion will be performed during config tree building
instead of schema itself tree building stage

${./name} - insert mentioned node value into position at first stage
$${./name} - the same but at the sacond stage.
$[n]{./name} - at the n-th stage

Plugin for variable expansion.

data scheme is config itself
What does scheme allow to do? Automatic type conversion from original or
genuine tree. For example, string "white" for color will be converted into
1-element blob with element length == 4(bytes)

What blob is:

/*
 * TODO: consider cash thrashing. Try to maintain spatial locality! Try to
 * use arrays instead of lists or place list nodes near each other.
 */
 
typedef struct {
	uint32_t length;
	char data[];
} data_t;

//  == 1 if saved on big-endian host
#define BLOB_BIG_ENDIAN 256
// == 1 if is floating point number
#define BLOB_FLOAT 512
// == 1 if blob is array of elements
#define BLOB_ARRAY 1024
// block size (or size of element in the case of array)
#define BLOB_LENGTH_MASK 255

typedef struct {
	int options;
	
	union {
		char value[];
		data_t data;
	};
} blob;

#define NODE_VIRTUAL 1
typedef struct {
	int options;

	node_class *class;
	union {
		blob value;
		data_t instance;
	}
} node;

Methods:
#define CLASS_HAS_get_iter_succ 1
#define CLASS_HAS_get_iter_pred 2
#define CLASS_HAS_get_succ 4
#define CLASS_HAS_get_pred 8
#define CLASS_HAS_add_succ 16
#define CLASS_HAS_add_pred 32
#define CLASS_HAS_del_succ 64
#define CLASS_HAS_del_pred 128
#define CLASS_HAS_get_value 256
#define CLASS_HAS_set_value 512
#define CLASS_HAS_destroy 1024

typedef int (*get_iter_succ_m)();
typedef int (*get_iter_pred_m)();
typedef int (*get_succ_m)();
typedef int (*get_pred_m)();
typedef int (*add_succ_m)();
typedef int (*add_pred_m)();
typedef int (*del_succ_m)();
typedef int (*del_pred_m)();
typedef int (*get_value_m)();
typedef int (*set_value_m)();
typedef int (*destroy_m)();

typedef struct {
	int mset;
	void* methods[];
}

Tool for test configuration. Again, we need the module for configuration versioning!

Probably, we should have ability to backup and store succesful configurations of system
in our advanced versioning plugin. Yep, something similar to restore points in
EvilXP/NT/2000/3000/10000

Run-time configuration editing with mentioned toolbox. Adding/deleting in runtime. Not
sure about how exactly application should be notified about config change.

Module mounter - mount different part of tree to new position.
Module lazy builder - ping underlaid sub-tree module only when accessed
Module cacher - cache config into provided sub-tree of global namespace
Module engine::shm - stores result into shared memory segments; may be useful with cacher

Don't forget about config-selection globbing with XPath like expressions. We should have
an ability to build virtual subtree from real one with help of XPath-like expression.

Idea of "layers" of configuration. Actually, tree might be represented as 3d construction
where Z-coordinate is responsible for concrete layer of configuration. Layers are combined
according to their priority to d[it out resulting configuration tree.
Example of layers:
-hardware - configuration tree for particular hardware platform
-system - conf tree for particular OS installation
-user - conf tree related to loggged-in user.
...
Application can have self-defined configuration layers.
Layers are being applied as series of pathes. Resulting tree might obtain
on of its values from one level and another value from another. Values can
interfere with each other. I think word priority in this area would be
sufficient but I'm not sure. Separate plugin should be provided for such
kind of feature.

Allow in scheme plugin units of measurement.

Plugin-calculator which allows to perform calculations during config read. Kind
of setter-getter virtual variable.

We should discuss cyclic graph problem in the case of dependency in tree's
members computation.

Implement elementary caching inside graph node itself. Therefore, implement
virtual methods table pointer to enable pluggable behavior.
