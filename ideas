Path selection patterns ( /root/*/access) which can be sources for "virtual trees"

What we shold handle?
-virtual or surrogate trees (trees or value, calculated on-the-fly without any storage)
-caching and memoization of virtual trees
-linking values to each other and linking fragments of trees which mimics concept of mounts in filesystem
-transactional changes with comments (mimics special tables in SQL DBs we can store transactions in the same configuration tree)
-handle comments as a part of configuration
-scripting of handlers for virtual trees or variables
-access control (possibly would be useful to store attributes with the same interface of configuration as MySQL does)

Look at XPath and XQuery!

Library datamodel regarding basic types follows strictly typed languages:
there is following decimal types scheme:
{ signed | unsigned } int[ 8 | 16 | 32 | 64 ]
there are floating point type:
float | double
there are bitfield type:
bits[ num ] // num == 1 - boolean value

complex types simulated via special things:
node dictionary adapters:
hash, -  any regular datatype
patricia, - strings (default)
array, - child node names in such node is numbers only
{ sorted | unsorted } list -

pluggable datatype system

config schemas with comments and type definition. variables are allowed. for example:

plugin {
	name = string;
	config = subtree( ../plugins/$${./name} )
}

here is ./name should be string or convertable to string parameter
$$ means that expansion will be performed during config tree building
instead of schema itself tree building stage

data scheme is config itself
What does scheme allow to do? Automatic type conversion from original or
genuine tree. For example, string "white" for color will be converted into
1-element blob with element length == 4(bytes)

What blob is:

typedef struct {
  unsigned int bendian : 1; //  == 1 if saved on big-endian host
  unsigned int float : 1; // == 1 if is floating point number
  unsigned int array : 1; // == 1 if blob is array of elements
  unsigned int bsize : 5; // block size (or size of element in the case of array)
} header;

typedef struct {
  header;
  char data[];
} scalar;

typedef struct {
  header;
  uint32_t length;
  char data[];
} vector;

Tool for test configuration. Again, we need the module for configuration versioning!

Probably, we should have ability to backup and store succesful configurations of system
in our advanced versioning plugin. Yep, something similar to restore points in
EvilXP/NT/2000/3000/10000

Run-time configuration editing with mentioned toolbox. Adding/deleting in runtime. Not
sure about how exactly application should be notified about config change.

